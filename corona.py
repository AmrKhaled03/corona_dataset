# -*- coding: utf-8 -*-
"""corona

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zF6Hn8C6IeJBrfIswOAbY2LleBC5Gs_I
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# Path to your data file on Google Drive
file_path = '/content/drive/MyDrive/AI/country_wise_latest.csv.xls'

# Load the data into a DataFrame
df = pd.read_csv(file_path)

df.head()

print(df.columns)

import networkx as nx

# Create an empty graph
G = nx.Graph()

# Add nodes (countries) to the graph
countries = df['Country/Region'].unique()
for country in countries:
    G.add_node(country)

# Add edges with weights (confirmed cases) to the graph
for _, row in df.iterrows():
    source = row['Country/Region']
    confirmed = row['Confirmed']
    for _, inner_row in df.iterrows():
        destination = inner_row['Country/Region']
        weight = float(inner_row['Confirmed'])
        if source != destination:
            G.add_edge(source, destination, weight=weight)

# Now the graph G is constructed, with countries as nodes and the number of confirmed cases as edge weights

from queue import Queue

def bfs(graph, start):
    visited = set()
    queue = Queue()
    queue.put(start)
    while not queue.empty():
        node = queue.get()
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbor in graph.neighbors(node):
                if neighbor not in visited:
                    queue.put(neighbor)

def dfs(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbor in graph.neighbors(node):
                if neighbor not in visited:
                    stack.append(neighbor)

from heapq import heappush, heappop
from math import sqrt

def heuristic(node, goal):
    # Check if the nodes have latitude and longitude attributes
    if 'latitude' in G.nodes[node] and 'longitude' in G.nodes[node] and 'latitude' in G.nodes[goal] and 'longitude' in G.nodes[goal]:
        # Use the Euclidean distance heuristic
        node_position = (G.nodes[node]['latitude'], G.nodes[node]['longitude'])
        goal_position = (G.nodes[goal]['latitude'], G.nodes[goal]['longitude'])
        return sqrt((node_position[0] - goal_position[0]) ** 2 + (node_position[1] - goal_position[1]) ** 2)
    else:
        # If latitude and longitude are missing or not numeric, return a default value
        return 0

def astar(graph, start, goal):
    pq = []  # Priority queue for A* search
    heappush(pq, (0, start))  # Push the start node with priority 0
    visited = set()  # Set to track visited nodes
    while pq:
        cost, current_node = heappop(pq)  # Pop the node with the lowest priority
        if current_node == goal:
            print("Goal reached:", current_node)  # Print when the goal is reached
            return  # Goal reached
        if current_node not in visited:
            visited.add(current_node)
            for neighbor in graph.neighbors(current_node):
                if neighbor not in visited:
                    # Calculate the cost of reaching the neighbor node
                    new_cost = cost + graph[current_node][neighbor]['weight']
                    # Calculate the total estimated cost through this neighbor
                    total_cost = new_cost + heuristic(neighbor, goal)
                    # Push the neighbor node with its priority (total cost)
                    heappush(pq, (total_cost, neighbor))

def uniform_cost_search(graph, start, goal):
    pq = []  # Priority queue for uniform cost search
    heappush(pq, (0, start))  # Push the start node with priority 0
    visited = set()  # Set to track visited nodes
    while pq:
        cost, current_node = heappop(pq)  # Pop the node with the lowest priority
        if current_node == goal:
            return  # Goal reached
        if current_node not in visited:
            visited.add(current_node)
            for neighbor in graph.neighbors(current_node):
                if neighbor not in visited:
                    # Calculate the cost of reaching the neighbor node
                    new_cost = cost + graph[current_node][neighbor]['weight']
                    # Push the neighbor node with its priority (total cost)
                    heappush(pq, (new_cost, neighbor))

# Print the nodes in the graph to verify if 'start_node' is present
print("Nodes in the graph:", G.nodes())

# Assuming you have chosen 'Afghanistan' as the start node
start_node = 'Afghanistan'
# Assuming you have defined the goal node
goal_node = 'Zimbabwe'    # Replace with your actual goal node

# Applying BFS
print("Breadth-First Search:")
bfs(G, start_node)

# Applying DFS
print("\nDepth-First Search:")
dfs(G, start_node)

# Applying A* search
print("\nA* Search:")
astar(G, start_node, goal_node)

# Applying Uniform Cost Search
print("\nUniform Cost Search:")
uniform_cost_search(G, start_node, goal_node)